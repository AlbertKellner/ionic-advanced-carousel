(function () {
    'use strict';

    angular
        .module('sebelga.ionic', [])
        .directive('aCarousel', advancedCarousel);

    advancedCarousel.$inject = ['$compile', '$timeout', '$ionicScrollDelegate'];
    function advancedCarousel($compile, $timeout, $ionicScrollDelegate) {
        return {
            restrict        : 'E',
            replace         : true,
            template        : '',
            scope           : {},
            link            : linkFunc,
            controller      : Controller,
            controllerAs    : 'vm',
            bindToController: {
                itemDirective  : '@',
                carouselOptions: '=',
                arrayProvider  : '=',
                onSelect       : '&'
            }
        };

        /////////

        function linkFunc(scope, el, attr, ctrl) {
            ctrl.el = el;

            ctrl.options.trackBy    = typeof attr.trackBy !== 'undefined' ? attr.trackBy : '$index';
            ctrl.options.trackBystr = ctrl.options.trackBy === '$index' ? '$index' : 'item.' + ctrl.options.trackBy;

            var animateIn = ctrl.options.animateIn ? ' animateIn' : '';

            // Dynamic directive html
            // ----------------------
            var html = '<div class="a-carousel">';

            if (ctrl.options.pullRefresh.active) {
                html += '<div class="spinner-wrapper" ng-if="vm.options.pullRefresh.loading"><ion-spinner icon="android"></ion-spinner></div>';
                html += '<span class="pullrefresh-indicator">' +
                    '<svg viewBox="0 0 64 64"><g>' +
                    '<circle stroke-width="6" stroke-dasharray="135.26261239144287" stroke-dashoffset="16.51371474556214" ' +
                    'r="26" cx="32" cy="32" fill="none" transform="scale(1,1) translate(0,0) rotate(0,32,32)"></circle></g>' +
                    '</svg>' +
                    '</span>';
            }

            html += '<ion-scroll ';

            if (ctrl.options.pullRefresh.active) {
                html += 'on-scroll="vm.onScroll()" ';
            }

            html += 'scrollbar-x="false" delegate-handle="' + ctrl.options.carouselId + '" ' +
                'zooming="false" direction="x" has-bouncing="true">' +
                '<nav style="visibility:hidden;">' +
                '<ul> <li ' +
                'ng-repeat="item in vm.arrayProvider track by ' +
                ctrl.options.trackBystr + '"' +
                'class="carousel-item' + animateIn + '"' +
                'ng-class="{\'active\':vm.itemActive === item}">' +
                createItemDirective() +
                '</li>' +
                '</ul></nav></ion-scroll></div>';

            // Compile dynamic template
            html = $compile(html)(scope);
            el.append(html);

            /**
             * $timeout so ng-repeat is finished in order to calculate width of carousel
             */
            $timeout(function () {
                if (ctrl.arrayProvider && ctrl.arrayProvider.length > 0) {
                    ctrl.initCarousel();
                }

                allowVerticalScroll();
            }, 0);

            function createItemDirective() {
                var template = ctrl.options.template !== null ? 'template="' + ctrl.options.template + '"' : '';

                var directive = '<' + ctrl.itemDirective + ' ng-model="item" ' + template +
                    'on-select="vm.selectItem(item)" carousel-options="menuCarousel.options" ';
                directive += '></' + ctrl.itemDirective + '>';

                return directive;
            }

            // this method allows to scroll the page below the carousel
            function allowVerticalScroll() {
                var sv        = $ionicScrollDelegate.$getByHandle(ctrl.options.carouselId).getScrollView();
                var container = sv.__container;

                var originaltouchStart = sv.touchStart;
                var originaltouchMove  = sv.touchMove;

                container.removeEventListener('touchstart', sv.touchStart);
                document.removeEventListener('touchmove', sv.touchMove);

                sv.touchStart = function (e) {
                    e.preventDefault = function () {
                    };
                    originaltouchStart.apply(sv, [e]);
                };

                sv.touchMove = function (e) {
                    e.preventDefault = function () {
                    };
                    originaltouchMove.apply(sv, [e]);
                };

                container.addEventListener('touchstart', sv.touchStart, false);
                document.addEventListener('touchmove', sv.touchMove, false);
            }
        }
    }

    Controller.$inject = ['$scope', '$element', '$timeout', '$window', '$ionicScrollDelegate'];
    function Controller($scope, $element, $timeout, $window, $ionicScrollDelegate) {
        var vm = this;

        vm.options = {
            showScroll    : false,
            carouselId    : 'my-carousel',
            template      : null,
            align         : 'left',
            centerOnSelect: true,
            widthItem     : 0,
            heightItem    : 0,
            trackBy       : '$index',
            selectFirst   : true,
            selectAtStart : {
                property: null,
                value   : null,
                index   : -1
            },
            pullRefresh   : {
                active  : false,
                callBack: angular.noop,
                loading:false
            },
            animateIn     : false
        };

        // API
        vm.initCarousel = initCarousel;
        vm.selectItem   = selectItem;
        vm.onScroll     = onScroll;

        activate();

        //////////

        function activate() {
            angular.extend(vm.options, vm.carouselOptions);

            $scope.$on('a-carousel.arrayupdated', onArrayProviderUpdated);
            $scope.$on('a-carousel.desactivateItem', desactiveItemSelected);

            if (vm.options.pullRefresh.active) {
                $scope.$on('a-carousel.pullrefresh.done', onEndRefresh);
            }

            //////////
            /**
             *
             * @param e
             * @param {{carouselId:string}} param
             */
            function onArrayProviderUpdated(e, param) {
                var carouselId;
                if (typeof param === 'object') {
                    carouselId = param.carouselId;
                    angular.extend(vm.options, param);
                } else {
                    carouselId = param;
                }

                if (carouselId === vm.options.carouselId) {
                    $timeout(vm.initCarousel, 0);
                }
            }

            /**
             *
             * @param e
             * @param {{idContains:string, except:string}} param
             */
            function desactiveItemSelected(e, param) {
                var idContains = param.idContains;
                var except     = param.except;

                if (vm.options.carouselId.indexOf(idContains) >= 0 && vm.options.carouselId !== except) {
                    vm.itemActive = null;
                }
            }
        }

        function initCarousel() {
            var carouselItems = $element.find('li');
            var totalItems    = carouselItems.length;
            var numItems      = angular.element(carouselItems).length;
            var widthCarousel = 0;

            var marginLeft  = 0;
            var marginRight = 0;

            var index              = 0;
            var numTimesDomChecked = 0;
            var numRetryBuild           = 15;

            vm.itemActive = null;

            if (numItems > 0) {
                $timeout(function () {
                    checkDOM();
                }, 50);
            } else {
                throw Error('Trying to create a carousel from an empty array', vm.options);
            }

            function checkDOM() {
                // Checking if carousel items are in DOM
                var w = parseInt(carouselItems[totalItems - 1].offsetWidth);
                var h = parseInt(carouselItems[totalItems - 1].offsetHeight);

                if (w > 0 && h > 0) {
                    processNow();
                } else {
                    console.log('[INFO] Creating Carousel but DOM not ready yet...');

                    if (numTimesDomChecked < numRetryBuild) {
                        $timeout(function () {
                            checkDOM();
                        }, 50);
                    } else {
                        console.log('[ERROR] Size item Carousel could not be determined', vm.options.carouselId);
                    }

                    numTimesDomChecked++;
                }
            }

            function processNow() {
                var selectItemAtStart = vm.options.selectAtStart.property !== null;
                var modelItem;

                angular.forEach(carouselItems, function (item) {
                    modelItem            = vm.arrayProvider[index];
                    modelItem.carouselId = vm.options.carouselId;

                    widthCarousel += item.offsetWidth;
                    vm.options.widthItem  = Math.max(item.offsetWidth, vm.options.widthItem);
                    vm.options.heightItem = Math.max(item.offsetHeight, vm.options.heightItem);

                    vm.arrayProvider[index].widthItem = item.offsetWidth;

                    // As we can select at start an item with a property of certain value
                    // we check here its index in the Array
                    if (selectItemAtStart && vm.options.selectAtStart.index === -1) {
                        if (modelItem[vm.options.selectAtStart.property] === vm.options.selectAtStart.value) {
                            vm.options.selectAtStart.index = index;
                        }
                    }

                    index += 1;
                });

                if (vm.options.centerOnSelect) {
                    var centerX   = $window.innerWidth * 0.5;
                    var firstItem = carouselItems[0];
                    var lastItem  = carouselItems[numItems - 1];

                    marginLeft  = centerX - firstItem.offsetWidth * 0.5;
                    marginRight = centerX - lastItem.offsetWidth * 0.5;

                    // we add margin on both side to be able to center the first and last item
                    widthCarousel += marginLeft + marginRight;

                    vm.options.maxScroll = $window.innerWidth - widthCarousel;

                    // position the carousel on first item
                    if (vm.options.align === 'right') {
                        $ionicScrollDelegate
                            .$getByHandle(vm.options.carouselId)
                            .scrollTo(vm.options.maxScroll * -1, 0, false);
                    } else if (vm.options.align === 'center') {
                        $ionicScrollDelegate
                            .$getByHandle(vm.options.carouselId)
                            .scrollTo(vm.options.maxScroll * -0.5, 0, false);
                    } else {
                        $ionicScrollDelegate
                            .$getByHandle(vm.options.carouselId)
                            .scrollTo(0, 0, true);
                    }

                } else {
                    widthCarousel += 4; // + 4 to avoid line break when text going bold
                    vm.options.maxScroll = $window.innerWidth - widthCarousel;
                }

                vm.options.widthCarousel = widthCarousel;

                // Set Active item at start
                if (!selectItemAtStart && vm.options.selectFirst) {
                    if (vm.options.align === 'right') {
                        setItemActive(vm.arrayProvider[numItems - 1]);
                    } else {
                        setItemActive(vm.arrayProvider[0]);
                    }
                } else {
                    if (selectItemAtStart && vm.options.selectAtStart.index !== -1) {
                        selectItem(vm.arrayProvider[vm.options.selectAtStart.index]);
                    }
                }

                // Apply inline-css to carousel according to items width and height
                vm.navElem = $element.find('nav');
                vm.navElem.css({
                    'width'       : widthCarousel + 'px',
                    'height'      : vm.options.heightItem + 'px',
                    'visibility'  : 'visible',
                    'padding-left': marginLeft + 'px'
                });

                // Cache pull refresh DOM elements (both wrapper and svg elem)
                if (vm.options.pullRefresh.active) {
                    vm.pullrefreshIndicator = angular.element(document.querySelector('.menu-carousel .pullrefresh-indicator'));
                    vm.svgElem              = $element.find('g');
                }
            }
        }

        function selectItem(item) {
            var scrollPos, i;

            setItemActive(item);

            // Center carousel
            if (vm.options.centerOnSelect) {
                var index = getIndexFromId(item);

                scrollPos = 0;

                if (index === 0) {
                    scrollPos = 0;
                } else {
                    for (i = 0; i < index; i++) {
                        scrollPos += (vm.arrayProvider[i].widthItem + vm.arrayProvider[i + 1].widthItem) * 0.5;
                    }
                }

                $ionicScrollDelegate.$getByHandle(vm.options.carouselId).scrollTo(scrollPos, 0, true);
            }
        }

        /**
         * Only for when pull-refresh active is set
         */
        function onScroll() {
            var pct;
            var pos             = $ionicScrollDelegate.$getByHandle(vm.options.carouselId).getScrollPosition().left;
            var pctPull         = 0;
            var pctRotIndicator = 0;

            if (vm.options.maxScroll < 0) {
                pct = pos / vm.options.maxScroll * -1;
            } else {
                // If NO maxScroll -> probably means that there are only 1 or 2 items (no need to scroll)
                // we fake a percentage
                pct = pos / 10;
            }

            if (pct > 1) {
                var pixelPull = pos - vm.options.maxScroll * -1;
                pctPull       = pixelPull / $window.innerWidth;
                vm.pullrefreshIndicator.css({'transform': 'translateX(' + pctRotIndicator * -56 + 'px)'});
            }

            if (pctPull > 0.25 && pos > 0) {
                vm.pullrefreshIndicator.css({'transform': 'translateX(0px)', display: 'none'});
                onPullRefresh();
            } else {
                pctRotIndicator = pctPull / 0.2;
                vm.svgElem[0].setAttribute('transform', 'rotate(' + pctRotIndicator * 360 + ' 32 32)');
                vm.pullrefreshIndicator.css({'transform': 'translateX(' + pctRotIndicator * -56 + 'px)'});
            }
        }

        // ----------
        // PRIVATE
        // ----------
        function setItemActive(item) {
            vm.itemActive = item;

            // Callback on select
            vm.onSelect.call(null, {item: item});

            $scope.$broadcast('a-carousel.itemselected', item);
        }

        function getIndexFromId(item) {
            for (var i in vm.arrayProvider) {
                if (vm.arrayProvider[i] === item) {
                    return i;
                }
            }
        }

        // Pull Refresh
        function onPullRefresh() {
            if (!vm.options.pullRefresh.loading) {
                $scope.$apply(function () {
                    vm.options.pullRefresh.loading = true;
                });

                $ionicScrollDelegate.$getByHandle(vm.options.carouselId).freezeScroll(true);

                // Add some width to the nav to make some room for the spinner
                vm.navElem.css({'width': vm.options.widthCarousel + 45 + 'px'});
                $ionicScrollDelegate.$getByHandle(vm.options.carouselId).resize();

                vm.options.pullRefresh.callBack();
            }

        }

        function onEndRefresh() {
            vm.options.pullRefresh.loading = false;

            vm.navElem.css({'width': vm.options.widthCarousel + 'px'});
            $ionicScrollDelegate.$getByHandle(vm.options.carouselId).resize();

            $ionicScrollDelegate.$getByHandle(vm.options.carouselId).freezeScroll(false);
            vm.pullrefreshIndicator.css({'transform': 'translateX(0px)', display: 'block'});
        }
    }
})();

(function () {
    'use strict';

    angular
        .module('sebelga.ionic')
        .directive('carouselTextItem', carouselTextItem);

    function carouselTextItem() {
        return {
            restrict        : 'E',
            replace         : true,
            template        : '<a class="a-carousel-text-item"' +
                                'ng-bind="vm.ngModel.display"' +
                                'ng-click="vm.onSelect({item:vm.ngModel})">' +
                                '</a>',
            scope           : {},
            controller      : Controller,
            controllerAs    : 'vm',
            bindToController: {
                ngModel        : '=',
                onSelect       : '&'
            }
        };
    }


    Controller.$inject = ['$scope'];
    function Controller($scope) {
        var vm      = this;
        vm.selected = false;

        activate();

        function activate() {
            $scope.$on('acarousel.itemselected', function (event, item) {
                vm.selected = item === vm.ngModel ? true : false;
            });
        }
    }
})();

(function () {
    'use strict';

    var scripts = document.getElementsByTagName("script")
    var currentScriptPath = scripts[scripts.length-1].src;

    angular
        .module('sebelga.ionic')
        .directive('carouselGenericItem', carouselGenericItem);

    function carouselGenericItem() {
        return {
            restrict        : 'E',
            replace         : true,
            templateUrl     : function (elem, attr) {
                //if (!attr.template) {
                //    throw Error('Template missing for advanced carousel item');
                //}
                //return currentScriptPath.replace('carousel-generic-item.js', 'carousel-generic-' + attr.template + '.html');
                return attr.template;
            },
            scope           : {},
            controller      : Controller,
            controllerAs    : 'vm',
            bindToController: {
                ngModel        : '=',
                onSelect       : '&',
                carouselOptions: '='
            }
        };
    }

    Controller.$inject = ['$scope'];
    function Controller($scope) {
        var vm      = this;
        vm.selected = false;

        activate();

        function activate() {
            $scope.$on('a-carousel.itemselected', function (event, item) {
                vm.selected = item === vm.ngModel ? true : false;
            });
        }
    }
})();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFkdmFuY2VkLWNhcm91c2VsLmpzIiwiY2Fyb3VzZWwtdGV4dC1pdGVtLmpzIiwiY3VzdG9tLWRpcmVjdGl2ZXMvY2Fyb3VzZWwtZ2VuZXJpYy1pdGVtLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMxYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImFkdmFuY2VkLWNhcm91c2VsLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhclxuICAgICAgICAubW9kdWxlKCdzZWJlbGdhLmlvbmljJywgW10pXG4gICAgICAgIC5kaXJlY3RpdmUoJ2FDYXJvdXNlbCcsIGFkdmFuY2VkQ2Fyb3VzZWwpO1xuXG4gICAgYWR2YW5jZWRDYXJvdXNlbC4kaW5qZWN0ID0gWyckY29tcGlsZScsICckdGltZW91dCcsICckaW9uaWNTY3JvbGxEZWxlZ2F0ZSddO1xuICAgIGZ1bmN0aW9uIGFkdmFuY2VkQ2Fyb3VzZWwoJGNvbXBpbGUsICR0aW1lb3V0LCAkaW9uaWNTY3JvbGxEZWxlZ2F0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3QgICAgICAgIDogJ0UnLFxuICAgICAgICAgICAgcmVwbGFjZSAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHRlbXBsYXRlICAgICAgICA6ICcnLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICBsaW5rICAgICAgICAgICAgOiBsaW5rRnVuYyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXIgICAgICA6IENvbnRyb2xsZXIsXG4gICAgICAgICAgICBjb250cm9sbGVyQXMgICAgOiAndm0nLFxuICAgICAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xuICAgICAgICAgICAgICAgIGl0ZW1EaXJlY3RpdmUgIDogJ0AnLFxuICAgICAgICAgICAgICAgIGNhcm91c2VsT3B0aW9uczogJz0nLFxuICAgICAgICAgICAgICAgIGFycmF5UHJvdmlkZXIgIDogJz0nLFxuICAgICAgICAgICAgICAgIG9uU2VsZWN0ICAgICAgIDogJyYnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8vLy8vLy8vXG5cbiAgICAgICAgZnVuY3Rpb24gbGlua0Z1bmMoc2NvcGUsIGVsLCBhdHRyLCBjdHJsKSB7XG4gICAgICAgICAgICBjdHJsLmVsID0gZWw7XG5cbiAgICAgICAgICAgIGN0cmwub3B0aW9ucy50cmFja0J5ICAgID0gdHlwZW9mIGF0dHIudHJhY2tCeSAhPT0gJ3VuZGVmaW5lZCcgPyBhdHRyLnRyYWNrQnkgOiAnJGluZGV4JztcbiAgICAgICAgICAgIGN0cmwub3B0aW9ucy50cmFja0J5c3RyID0gY3RybC5vcHRpb25zLnRyYWNrQnkgPT09ICckaW5kZXgnID8gJyRpbmRleCcgOiAnaXRlbS4nICsgY3RybC5vcHRpb25zLnRyYWNrQnk7XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRlSW4gPSBjdHJsLm9wdGlvbnMuYW5pbWF0ZUluID8gJyBhbmltYXRlSW4nIDogJyc7XG5cbiAgICAgICAgICAgIC8vIER5bmFtaWMgZGlyZWN0aXZlIGh0bWxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHZhciBodG1sID0gJzxkaXYgY2xhc3M9XCJhLWNhcm91c2VsXCI+JztcblxuICAgICAgICAgICAgaWYgKGN0cmwub3B0aW9ucy5wdWxsUmVmcmVzaC5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwic3Bpbm5lci13cmFwcGVyXCIgbmctaWY9XCJ2bS5vcHRpb25zLnB1bGxSZWZyZXNoLmxvYWRpbmdcIj48aW9uLXNwaW5uZXIgaWNvbj1cImFuZHJvaWRcIj48L2lvbi1zcGlubmVyPjwvZGl2Pic7XG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHNwYW4gY2xhc3M9XCJwdWxscmVmcmVzaC1pbmRpY2F0b3JcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxzdmcgdmlld0JveD1cIjAgMCA2NCA2NFwiPjxnPicgK1xuICAgICAgICAgICAgICAgICAgICAnPGNpcmNsZSBzdHJva2Utd2lkdGg9XCI2XCIgc3Ryb2tlLWRhc2hhcnJheT1cIjEzNS4yNjI2MTIzOTE0NDI4N1wiIHN0cm9rZS1kYXNob2Zmc2V0PVwiMTYuNTEzNzE0NzQ1NTYyMTRcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3I9XCIyNlwiIGN4PVwiMzJcIiBjeT1cIjMyXCIgZmlsbD1cIm5vbmVcIiB0cmFuc2Zvcm09XCJzY2FsZSgxLDEpIHRyYW5zbGF0ZSgwLDApIHJvdGF0ZSgwLDMyLDMyKVwiPjwvY2lyY2xlPjwvZz4nICtcbiAgICAgICAgICAgICAgICAgICAgJzwvc3ZnPicgK1xuICAgICAgICAgICAgICAgICAgICAnPC9zcGFuPic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGh0bWwgKz0gJzxpb24tc2Nyb2xsICc7XG5cbiAgICAgICAgICAgIGlmIChjdHJsLm9wdGlvbnMucHVsbFJlZnJlc2guYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgaHRtbCArPSAnb24tc2Nyb2xsPVwidm0ub25TY3JvbGwoKVwiICc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGh0bWwgKz0gJ3Njcm9sbGJhci14PVwiZmFsc2VcIiBkZWxlZ2F0ZS1oYW5kbGU9XCInICsgY3RybC5vcHRpb25zLmNhcm91c2VsSWQgKyAnXCIgJyArXG4gICAgICAgICAgICAgICAgJ3pvb21pbmc9XCJmYWxzZVwiIGRpcmVjdGlvbj1cInhcIiBoYXMtYm91bmNpbmc9XCJ0cnVlXCI+JyArXG4gICAgICAgICAgICAgICAgJzxuYXYgc3R5bGU9XCJ2aXNpYmlsaXR5OmhpZGRlbjtcIj4nICtcbiAgICAgICAgICAgICAgICAnPHVsPiA8bGkgJyArXG4gICAgICAgICAgICAgICAgJ25nLXJlcGVhdD1cIml0ZW0gaW4gdm0uYXJyYXlQcm92aWRlciB0cmFjayBieSAnICtcbiAgICAgICAgICAgICAgICBjdHJsLm9wdGlvbnMudHJhY2tCeXN0ciArICdcIicgK1xuICAgICAgICAgICAgICAgICdjbGFzcz1cImNhcm91c2VsLWl0ZW0nICsgYW5pbWF0ZUluICsgJ1wiJyArXG4gICAgICAgICAgICAgICAgJ25nLWNsYXNzPVwie1xcJ2FjdGl2ZVxcJzp2bS5pdGVtQWN0aXZlID09PSBpdGVtfVwiPicgK1xuICAgICAgICAgICAgICAgIGNyZWF0ZUl0ZW1EaXJlY3RpdmUoKSArXG4gICAgICAgICAgICAgICAgJzwvbGk+JyArXG4gICAgICAgICAgICAgICAgJzwvdWw+PC9uYXY+PC9pb24tc2Nyb2xsPjwvZGl2Pic7XG5cbiAgICAgICAgICAgIC8vIENvbXBpbGUgZHluYW1pYyB0ZW1wbGF0ZVxuICAgICAgICAgICAgaHRtbCA9ICRjb21waWxlKGh0bWwpKHNjb3BlKTtcbiAgICAgICAgICAgIGVsLmFwcGVuZChodG1sKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiAkdGltZW91dCBzbyBuZy1yZXBlYXQgaXMgZmluaXNoZWQgaW4gb3JkZXIgdG8gY2FsY3VsYXRlIHdpZHRoIG9mIGNhcm91c2VsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3RybC5hcnJheVByb3ZpZGVyICYmIGN0cmwuYXJyYXlQcm92aWRlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuaW5pdENhcm91c2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWxsb3dWZXJ0aWNhbFNjcm9sbCgpO1xuICAgICAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUl0ZW1EaXJlY3RpdmUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gY3RybC5vcHRpb25zLnRlbXBsYXRlICE9PSBudWxsID8gJ3RlbXBsYXRlPVwiJyArIGN0cmwub3B0aW9ucy50ZW1wbGF0ZSArICdcIicgOiAnJztcblxuICAgICAgICAgICAgICAgIHZhciBkaXJlY3RpdmUgPSAnPCcgKyBjdHJsLml0ZW1EaXJlY3RpdmUgKyAnIG5nLW1vZGVsPVwiaXRlbVwiICcgKyB0ZW1wbGF0ZSArXG4gICAgICAgICAgICAgICAgICAgICdvbi1zZWxlY3Q9XCJ2bS5zZWxlY3RJdGVtKGl0ZW0pXCIgY2Fyb3VzZWwtb3B0aW9ucz1cIm1lbnVDYXJvdXNlbC5vcHRpb25zXCIgJztcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmUgKz0gJz48LycgKyBjdHJsLml0ZW1EaXJlY3RpdmUgKyAnPic7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aXZlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGlzIG1ldGhvZCBhbGxvd3MgdG8gc2Nyb2xsIHRoZSBwYWdlIGJlbG93IHRoZSBjYXJvdXNlbFxuICAgICAgICAgICAgZnVuY3Rpb24gYWxsb3dWZXJ0aWNhbFNjcm9sbCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3YgICAgICAgID0gJGlvbmljU2Nyb2xsRGVsZWdhdGUuJGdldEJ5SGFuZGxlKGN0cmwub3B0aW9ucy5jYXJvdXNlbElkKS5nZXRTY3JvbGxWaWV3KCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHN2Ll9fY29udGFpbmVyO1xuXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsdG91Y2hTdGFydCA9IHN2LnRvdWNoU3RhcnQ7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsdG91Y2hNb3ZlICA9IHN2LnRvdWNoTW92ZTtcblxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgc3YudG91Y2hTdGFydCk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgc3YudG91Y2hNb3ZlKTtcblxuICAgICAgICAgICAgICAgIHN2LnRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbHRvdWNoU3RhcnQuYXBwbHkoc3YsIFtlXSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHN2LnRvdWNoTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsdG91Y2hNb3ZlLmFwcGx5KHN2LCBbZV0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHN2LnRvdWNoU3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBzdi50b3VjaE1vdmUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIENvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgJyRlbGVtZW50JywgJyR0aW1lb3V0JywgJyR3aW5kb3cnLCAnJGlvbmljU2Nyb2xsRGVsZWdhdGUnXTtcbiAgICBmdW5jdGlvbiBDb250cm9sbGVyKCRzY29wZSwgJGVsZW1lbnQsICR0aW1lb3V0LCAkd2luZG93LCAkaW9uaWNTY3JvbGxEZWxlZ2F0ZSkge1xuICAgICAgICB2YXIgdm0gPSB0aGlzO1xuXG4gICAgICAgIHZtLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzaG93U2Nyb2xsICAgIDogZmFsc2UsXG4gICAgICAgICAgICBjYXJvdXNlbElkICAgIDogJ215LWNhcm91c2VsJyxcbiAgICAgICAgICAgIHRlbXBsYXRlICAgICAgOiBudWxsLFxuICAgICAgICAgICAgYWxpZ24gICAgICAgICA6ICdsZWZ0JyxcbiAgICAgICAgICAgIGNlbnRlck9uU2VsZWN0OiB0cnVlLFxuICAgICAgICAgICAgd2lkdGhJdGVtICAgICA6IDAsXG4gICAgICAgICAgICBoZWlnaHRJdGVtICAgIDogMCxcbiAgICAgICAgICAgIHRyYWNrQnkgICAgICAgOiAnJGluZGV4JyxcbiAgICAgICAgICAgIHNlbGVjdEZpcnN0ICAgOiB0cnVlLFxuICAgICAgICAgICAgc2VsZWN0QXRTdGFydCA6IHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogbnVsbCxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBpbmRleCAgIDogLTFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwdWxsUmVmcmVzaCAgIDoge1xuICAgICAgICAgICAgICAgIGFjdGl2ZSAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjYWxsQmFjazogYW5ndWxhci5ub29wLFxuICAgICAgICAgICAgICAgIGxvYWRpbmc6ZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbmltYXRlSW4gICAgIDogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBUElcbiAgICAgICAgdm0uaW5pdENhcm91c2VsID0gaW5pdENhcm91c2VsO1xuICAgICAgICB2bS5zZWxlY3RJdGVtICAgPSBzZWxlY3RJdGVtO1xuICAgICAgICB2bS5vblNjcm9sbCAgICAgPSBvblNjcm9sbDtcblxuICAgICAgICBhY3RpdmF0ZSgpO1xuXG4gICAgICAgIC8vLy8vLy8vLy9cblxuICAgICAgICBmdW5jdGlvbiBhY3RpdmF0ZSgpIHtcbiAgICAgICAgICAgIGFuZ3VsYXIuZXh0ZW5kKHZtLm9wdGlvbnMsIHZtLmNhcm91c2VsT3B0aW9ucyk7XG5cbiAgICAgICAgICAgICRzY29wZS4kb24oJ2EtY2Fyb3VzZWwuYXJyYXl1cGRhdGVkJywgb25BcnJheVByb3ZpZGVyVXBkYXRlZCk7XG4gICAgICAgICAgICAkc2NvcGUuJG9uKCdhLWNhcm91c2VsLmRlc2FjdGl2YXRlSXRlbScsIGRlc2FjdGl2ZUl0ZW1TZWxlY3RlZCk7XG5cbiAgICAgICAgICAgIGlmICh2bS5vcHRpb25zLnB1bGxSZWZyZXNoLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS4kb24oJ2EtY2Fyb3VzZWwucHVsbHJlZnJlc2guZG9uZScsIG9uRW5kUmVmcmVzaCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3tjYXJvdXNlbElkOnN0cmluZ319IHBhcmFtXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uQXJyYXlQcm92aWRlclVwZGF0ZWQoZSwgcGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgY2Fyb3VzZWxJZDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBjYXJvdXNlbElkID0gcGFyYW0uY2Fyb3VzZWxJZDtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5leHRlbmQodm0ub3B0aW9ucywgcGFyYW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcm91c2VsSWQgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY2Fyb3VzZWxJZCA9PT0gdm0ub3B0aW9ucy5jYXJvdXNlbElkKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KHZtLmluaXRDYXJvdXNlbCwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gZVxuICAgICAgICAgICAgICogQHBhcmFtIHt7aWRDb250YWluczpzdHJpbmcsIGV4Y2VwdDpzdHJpbmd9fSBwYXJhbVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBkZXNhY3RpdmVJdGVtU2VsZWN0ZWQoZSwgcGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaWRDb250YWlucyA9IHBhcmFtLmlkQ29udGFpbnM7XG4gICAgICAgICAgICAgICAgdmFyIGV4Y2VwdCAgICAgPSBwYXJhbS5leGNlcHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodm0ub3B0aW9ucy5jYXJvdXNlbElkLmluZGV4T2YoaWRDb250YWlucykgPj0gMCAmJiB2bS5vcHRpb25zLmNhcm91c2VsSWQgIT09IGV4Y2VwdCkge1xuICAgICAgICAgICAgICAgICAgICB2bS5pdGVtQWN0aXZlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0Q2Fyb3VzZWwoKSB7XG4gICAgICAgICAgICB2YXIgY2Fyb3VzZWxJdGVtcyA9ICRlbGVtZW50LmZpbmQoJ2xpJyk7XG4gICAgICAgICAgICB2YXIgdG90YWxJdGVtcyAgICA9IGNhcm91c2VsSXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIG51bUl0ZW1zICAgICAgPSBhbmd1bGFyLmVsZW1lbnQoY2Fyb3VzZWxJdGVtcykubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHdpZHRoQ2Fyb3VzZWwgPSAwO1xuXG4gICAgICAgICAgICB2YXIgbWFyZ2luTGVmdCAgPSAwO1xuICAgICAgICAgICAgdmFyIG1hcmdpblJpZ2h0ID0gMDtcblxuICAgICAgICAgICAgdmFyIGluZGV4ICAgICAgICAgICAgICA9IDA7XG4gICAgICAgICAgICB2YXIgbnVtVGltZXNEb21DaGVja2VkID0gMDtcbiAgICAgICAgICAgIHZhciBudW1SZXRyeUJ1aWxkICAgICAgICAgICA9IDE1O1xuXG4gICAgICAgICAgICB2bS5pdGVtQWN0aXZlID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKG51bUl0ZW1zID4gMCkge1xuICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tET00oKTtcbiAgICAgICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdUcnlpbmcgdG8gY3JlYXRlIGEgY2Fyb3VzZWwgZnJvbSBhbiBlbXB0eSBhcnJheScsIHZtLm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjaGVja0RPTSgpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVja2luZyBpZiBjYXJvdXNlbCBpdGVtcyBhcmUgaW4gRE9NXG4gICAgICAgICAgICAgICAgdmFyIHcgPSBwYXJzZUludChjYXJvdXNlbEl0ZW1zW3RvdGFsSXRlbXMgLSAxXS5vZmZzZXRXaWR0aCk7XG4gICAgICAgICAgICAgICAgdmFyIGggPSBwYXJzZUludChjYXJvdXNlbEl0ZW1zW3RvdGFsSXRlbXMgLSAxXS5vZmZzZXRIZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHcgPiAwICYmIGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NOb3coKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0lORk9dIENyZWF0aW5nIENhcm91c2VsIGJ1dCBET00gbm90IHJlYWR5IHlldC4uLicpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1UaW1lc0RvbUNoZWNrZWQgPCBudW1SZXRyeUJ1aWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tET00oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbRVJST1JdIFNpemUgaXRlbSBDYXJvdXNlbCBjb3VsZCBub3QgYmUgZGV0ZXJtaW5lZCcsIHZtLm9wdGlvbnMuY2Fyb3VzZWxJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBudW1UaW1lc0RvbUNoZWNrZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NOb3coKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdEl0ZW1BdFN0YXJ0ID0gdm0ub3B0aW9ucy5zZWxlY3RBdFN0YXJ0LnByb3BlcnR5ICE9PSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBtb2RlbEl0ZW07XG5cbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goY2Fyb3VzZWxJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxJdGVtICAgICAgICAgICAgPSB2bS5hcnJheVByb3ZpZGVyW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxJdGVtLmNhcm91c2VsSWQgPSB2bS5vcHRpb25zLmNhcm91c2VsSWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgd2lkdGhDYXJvdXNlbCArPSBpdGVtLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2bS5vcHRpb25zLndpZHRoSXRlbSAgPSBNYXRoLm1heChpdGVtLm9mZnNldFdpZHRoLCB2bS5vcHRpb25zLndpZHRoSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIHZtLm9wdGlvbnMuaGVpZ2h0SXRlbSA9IE1hdGgubWF4KGl0ZW0ub2Zmc2V0SGVpZ2h0LCB2bS5vcHRpb25zLmhlaWdodEl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZtLmFycmF5UHJvdmlkZXJbaW5kZXhdLndpZHRoSXRlbSA9IGl0ZW0ub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXMgd2UgY2FuIHNlbGVjdCBhdCBzdGFydCBhbiBpdGVtIHdpdGggYSBwcm9wZXJ0eSBvZiBjZXJ0YWluIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNoZWNrIGhlcmUgaXRzIGluZGV4IGluIHRoZSBBcnJheVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0SXRlbUF0U3RhcnQgJiYgdm0ub3B0aW9ucy5zZWxlY3RBdFN0YXJ0LmluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsSXRlbVt2bS5vcHRpb25zLnNlbGVjdEF0U3RhcnQucHJvcGVydHldID09PSB2bS5vcHRpb25zLnNlbGVjdEF0U3RhcnQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bS5vcHRpb25zLnNlbGVjdEF0U3RhcnQuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodm0ub3B0aW9ucy5jZW50ZXJPblNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VudGVyWCAgID0gJHdpbmRvdy5pbm5lcldpZHRoICogMC41O1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RJdGVtID0gY2Fyb3VzZWxJdGVtc1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RJdGVtICA9IGNhcm91c2VsSXRlbXNbbnVtSXRlbXMgLSAxXTtcblxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0ICA9IGNlbnRlclggLSBmaXJzdEl0ZW0ub2Zmc2V0V2lkdGggKiAwLjU7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0ID0gY2VudGVyWCAtIGxhc3RJdGVtLm9mZnNldFdpZHRoICogMC41O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGFkZCBtYXJnaW4gb24gYm90aCBzaWRlIHRvIGJlIGFibGUgdG8gY2VudGVyIHRoZSBmaXJzdCBhbmQgbGFzdCBpdGVtXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoQ2Fyb3VzZWwgKz0gbWFyZ2luTGVmdCArIG1hcmdpblJpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgIHZtLm9wdGlvbnMubWF4U2Nyb2xsID0gJHdpbmRvdy5pbm5lcldpZHRoIC0gd2lkdGhDYXJvdXNlbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbiB0aGUgY2Fyb3VzZWwgb24gZmlyc3QgaXRlbVxuICAgICAgICAgICAgICAgICAgICBpZiAodm0ub3B0aW9ucy5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGlvbmljU2Nyb2xsRGVsZWdhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuJGdldEJ5SGFuZGxlKHZtLm9wdGlvbnMuY2Fyb3VzZWxJZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2Nyb2xsVG8odm0ub3B0aW9ucy5tYXhTY3JvbGwgKiAtMSwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZtLm9wdGlvbnMuYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkaW9uaWNTY3JvbGxEZWxlZ2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4kZ2V0QnlIYW5kbGUodm0ub3B0aW9ucy5jYXJvdXNlbElkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zY3JvbGxUbyh2bS5vcHRpb25zLm1heFNjcm9sbCAqIC0wLjUsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRpb25pY1Njcm9sbERlbGVnYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLiRnZXRCeUhhbmRsZSh2bS5vcHRpb25zLmNhcm91c2VsSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNjcm9sbFRvKDAsIDAsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aENhcm91c2VsICs9IDQ7IC8vICsgNCB0byBhdm9pZCBsaW5lIGJyZWFrIHdoZW4gdGV4dCBnb2luZyBib2xkXG4gICAgICAgICAgICAgICAgICAgIHZtLm9wdGlvbnMubWF4U2Nyb2xsID0gJHdpbmRvdy5pbm5lcldpZHRoIC0gd2lkdGhDYXJvdXNlbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2bS5vcHRpb25zLndpZHRoQ2Fyb3VzZWwgPSB3aWR0aENhcm91c2VsO1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0IEFjdGl2ZSBpdGVtIGF0IHN0YXJ0XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RJdGVtQXRTdGFydCAmJiB2bS5vcHRpb25zLnNlbGVjdEZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2bS5vcHRpb25zLmFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJdGVtQWN0aXZlKHZtLmFycmF5UHJvdmlkZXJbbnVtSXRlbXMgLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJdGVtQWN0aXZlKHZtLmFycmF5UHJvdmlkZXJbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdEl0ZW1BdFN0YXJ0ICYmIHZtLm9wdGlvbnMuc2VsZWN0QXRTdGFydC5pbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW0odm0uYXJyYXlQcm92aWRlclt2bS5vcHRpb25zLnNlbGVjdEF0U3RhcnQuaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IGlubGluZS1jc3MgdG8gY2Fyb3VzZWwgYWNjb3JkaW5nIHRvIGl0ZW1zIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgICAgICAgICB2bS5uYXZFbGVtID0gJGVsZW1lbnQuZmluZCgnbmF2Jyk7XG4gICAgICAgICAgICAgICAgdm0ubmF2RWxlbS5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAnd2lkdGgnICAgICAgIDogd2lkdGhDYXJvdXNlbCArICdweCcsXG4gICAgICAgICAgICAgICAgICAgICdoZWlnaHQnICAgICAgOiB2bS5vcHRpb25zLmhlaWdodEl0ZW0gKyAncHgnLFxuICAgICAgICAgICAgICAgICAgICAndmlzaWJpbGl0eScgIDogJ3Zpc2libGUnLFxuICAgICAgICAgICAgICAgICAgICAncGFkZGluZy1sZWZ0JzogbWFyZ2luTGVmdCArICdweCdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIENhY2hlIHB1bGwgcmVmcmVzaCBET00gZWxlbWVudHMgKGJvdGggd3JhcHBlciBhbmQgc3ZnIGVsZW0pXG4gICAgICAgICAgICAgICAgaWYgKHZtLm9wdGlvbnMucHVsbFJlZnJlc2guYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZtLnB1bGxyZWZyZXNoSW5kaWNhdG9yID0gYW5ndWxhci5lbGVtZW50KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tZW51LWNhcm91c2VsIC5wdWxscmVmcmVzaC1pbmRpY2F0b3InKSk7XG4gICAgICAgICAgICAgICAgICAgIHZtLnN2Z0VsZW0gICAgICAgICAgICAgID0gJGVsZW1lbnQuZmluZCgnZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNlbGVjdEl0ZW0oaXRlbSkge1xuICAgICAgICAgICAgdmFyIHNjcm9sbFBvcywgaTtcblxuICAgICAgICAgICAgc2V0SXRlbUFjdGl2ZShpdGVtKTtcblxuICAgICAgICAgICAgLy8gQ2VudGVyIGNhcm91c2VsXG4gICAgICAgICAgICBpZiAodm0ub3B0aW9ucy5jZW50ZXJPblNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4RnJvbUlkKGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgc2Nyb2xsUG9zID0gMDtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxQb3MgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxQb3MgKz0gKHZtLmFycmF5UHJvdmlkZXJbaV0ud2lkdGhJdGVtICsgdm0uYXJyYXlQcm92aWRlcltpICsgMV0ud2lkdGhJdGVtKSAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICRpb25pY1Njcm9sbERlbGVnYXRlLiRnZXRCeUhhbmRsZSh2bS5vcHRpb25zLmNhcm91c2VsSWQpLnNjcm9sbFRvKHNjcm9sbFBvcywgMCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSBmb3Igd2hlbiBwdWxsLXJlZnJlc2ggYWN0aXZlIGlzIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gb25TY3JvbGwoKSB7XG4gICAgICAgICAgICB2YXIgcGN0O1xuICAgICAgICAgICAgdmFyIHBvcyAgICAgICAgICAgICA9ICRpb25pY1Njcm9sbERlbGVnYXRlLiRnZXRCeUhhbmRsZSh2bS5vcHRpb25zLmNhcm91c2VsSWQpLmdldFNjcm9sbFBvc2l0aW9uKCkubGVmdDtcbiAgICAgICAgICAgIHZhciBwY3RQdWxsICAgICAgICAgPSAwO1xuICAgICAgICAgICAgdmFyIHBjdFJvdEluZGljYXRvciA9IDA7XG5cbiAgICAgICAgICAgIGlmICh2bS5vcHRpb25zLm1heFNjcm9sbCA8IDApIHtcbiAgICAgICAgICAgICAgICBwY3QgPSBwb3MgLyB2bS5vcHRpb25zLm1heFNjcm9sbCAqIC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBOTyBtYXhTY3JvbGwgLT4gcHJvYmFibHkgbWVhbnMgdGhhdCB0aGVyZSBhcmUgb25seSAxIG9yIDIgaXRlbXMgKG5vIG5lZWQgdG8gc2Nyb2xsKVxuICAgICAgICAgICAgICAgIC8vIHdlIGZha2UgYSBwZXJjZW50YWdlXG4gICAgICAgICAgICAgICAgcGN0ID0gcG9zIC8gMTA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwY3QgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsUHVsbCA9IHBvcyAtIHZtLm9wdGlvbnMubWF4U2Nyb2xsICogLTE7XG4gICAgICAgICAgICAgICAgcGN0UHVsbCAgICAgICA9IHBpeGVsUHVsbCAvICR3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgICAgICB2bS5wdWxscmVmcmVzaEluZGljYXRvci5jc3Moeyd0cmFuc2Zvcm0nOiAndHJhbnNsYXRlWCgnICsgcGN0Um90SW5kaWNhdG9yICogLTU2ICsgJ3B4KSd9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBjdFB1bGwgPiAwLjI1ICYmIHBvcyA+IDApIHtcbiAgICAgICAgICAgICAgICB2bS5wdWxscmVmcmVzaEluZGljYXRvci5jc3Moeyd0cmFuc2Zvcm0nOiAndHJhbnNsYXRlWCgwcHgpJywgZGlzcGxheTogJ25vbmUnfSk7XG4gICAgICAgICAgICAgICAgb25QdWxsUmVmcmVzaCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwY3RSb3RJbmRpY2F0b3IgPSBwY3RQdWxsIC8gMC4yO1xuICAgICAgICAgICAgICAgIHZtLnN2Z0VsZW1bMF0uc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCAncm90YXRlKCcgKyBwY3RSb3RJbmRpY2F0b3IgKiAzNjAgKyAnIDMyIDMyKScpO1xuICAgICAgICAgICAgICAgIHZtLnB1bGxyZWZyZXNoSW5kaWNhdG9yLmNzcyh7J3RyYW5zZm9ybSc6ICd0cmFuc2xhdGVYKCcgKyBwY3RSb3RJbmRpY2F0b3IgKiAtNTYgKyAncHgpJ30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLVxuICAgICAgICAvLyBQUklWQVRFXG4gICAgICAgIC8vIC0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gc2V0SXRlbUFjdGl2ZShpdGVtKSB7XG4gICAgICAgICAgICB2bS5pdGVtQWN0aXZlID0gaXRlbTtcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgb24gc2VsZWN0XG4gICAgICAgICAgICB2bS5vblNlbGVjdC5jYWxsKG51bGwsIHtpdGVtOiBpdGVtfSk7XG5cbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdhLWNhcm91c2VsLml0ZW1zZWxlY3RlZCcsIGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0SW5kZXhGcm9tSWQoaXRlbSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB2bS5hcnJheVByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZtLmFycmF5UHJvdmlkZXJbaV0gPT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHVsbCBSZWZyZXNoXG4gICAgICAgIGZ1bmN0aW9uIG9uUHVsbFJlZnJlc2goKSB7XG4gICAgICAgICAgICBpZiAoIXZtLm9wdGlvbnMucHVsbFJlZnJlc2gubG9hZGluZykge1xuICAgICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2bS5vcHRpb25zLnB1bGxSZWZyZXNoLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgJGlvbmljU2Nyb2xsRGVsZWdhdGUuJGdldEJ5SGFuZGxlKHZtLm9wdGlvbnMuY2Fyb3VzZWxJZCkuZnJlZXplU2Nyb2xsKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHNvbWUgd2lkdGggdG8gdGhlIG5hdiB0byBtYWtlIHNvbWUgcm9vbSBmb3IgdGhlIHNwaW5uZXJcbiAgICAgICAgICAgICAgICB2bS5uYXZFbGVtLmNzcyh7J3dpZHRoJzogdm0ub3B0aW9ucy53aWR0aENhcm91c2VsICsgNDUgKyAncHgnfSk7XG4gICAgICAgICAgICAgICAgJGlvbmljU2Nyb2xsRGVsZWdhdGUuJGdldEJ5SGFuZGxlKHZtLm9wdGlvbnMuY2Fyb3VzZWxJZCkucmVzaXplKCk7XG5cbiAgICAgICAgICAgICAgICB2bS5vcHRpb25zLnB1bGxSZWZyZXNoLmNhbGxCYWNrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uRW5kUmVmcmVzaCgpIHtcbiAgICAgICAgICAgIHZtLm9wdGlvbnMucHVsbFJlZnJlc2gubG9hZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2bS5uYXZFbGVtLmNzcyh7J3dpZHRoJzogdm0ub3B0aW9ucy53aWR0aENhcm91c2VsICsgJ3B4J30pO1xuICAgICAgICAgICAgJGlvbmljU2Nyb2xsRGVsZWdhdGUuJGdldEJ5SGFuZGxlKHZtLm9wdGlvbnMuY2Fyb3VzZWxJZCkucmVzaXplKCk7XG5cbiAgICAgICAgICAgICRpb25pY1Njcm9sbERlbGVnYXRlLiRnZXRCeUhhbmRsZSh2bS5vcHRpb25zLmNhcm91c2VsSWQpLmZyZWV6ZVNjcm9sbChmYWxzZSk7XG4gICAgICAgICAgICB2bS5wdWxscmVmcmVzaEluZGljYXRvci5jc3Moeyd0cmFuc2Zvcm0nOiAndHJhbnNsYXRlWCgwcHgpJywgZGlzcGxheTogJ2Jsb2NrJ30pO1xuICAgICAgICB9XG4gICAgfVxufSkoKTtcbiIsIihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhclxuICAgICAgICAubW9kdWxlKCdzZWJlbGdhLmlvbmljJylcbiAgICAgICAgLmRpcmVjdGl2ZSgnY2Fyb3VzZWxUZXh0SXRlbScsIGNhcm91c2VsVGV4dEl0ZW0pO1xuXG4gICAgZnVuY3Rpb24gY2Fyb3VzZWxUZXh0SXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0ICAgICAgICA6ICdFJyxcbiAgICAgICAgICAgIHJlcGxhY2UgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICB0ZW1wbGF0ZSAgICAgICAgOiAnPGEgY2xhc3M9XCJhLWNhcm91c2VsLXRleHQtaXRlbVwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduZy1iaW5kPVwidm0ubmdNb2RlbC5kaXNwbGF5XCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25nLWNsaWNrPVwidm0ub25TZWxlY3Qoe2l0ZW06dm0ubmdNb2RlbH0pXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L2E+JyxcbiAgICAgICAgICAgIHNjb3BlICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgY29udHJvbGxlciAgICAgIDogQ29udHJvbGxlcixcbiAgICAgICAgICAgIGNvbnRyb2xsZXJBcyAgICA6ICd2bScsXG4gICAgICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XG4gICAgICAgICAgICAgICAgbmdNb2RlbCAgICAgICAgOiAnPScsXG4gICAgICAgICAgICAgICAgb25TZWxlY3QgICAgICAgOiAnJidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIENvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJ107XG4gICAgZnVuY3Rpb24gQ29udHJvbGxlcigkc2NvcGUpIHtcbiAgICAgICAgdmFyIHZtICAgICAgPSB0aGlzO1xuICAgICAgICB2bS5zZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIGFjdGl2YXRlKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gYWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAkc2NvcGUuJG9uKCdhY2Fyb3VzZWwuaXRlbXNlbGVjdGVkJywgZnVuY3Rpb24gKGV2ZW50LCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgdm0uc2VsZWN0ZWQgPSBpdGVtID09PSB2bS5uZ01vZGVsID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59KSgpO1xuIiwiKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpXG4gICAgdmFyIGN1cnJlbnRTY3JpcHRQYXRoID0gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aC0xXS5zcmM7XG5cbiAgICBhbmd1bGFyXG4gICAgICAgIC5tb2R1bGUoJ3NlYmVsZ2EuaW9uaWMnKVxuICAgICAgICAuZGlyZWN0aXZlKCdjYXJvdXNlbEdlbmVyaWNJdGVtJywgY2Fyb3VzZWxHZW5lcmljSXRlbSk7XG5cbiAgICBmdW5jdGlvbiBjYXJvdXNlbEdlbmVyaWNJdGVtKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3QgICAgICAgIDogJ0UnLFxuICAgICAgICAgICAgcmVwbGFjZSAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsICAgICA6IGZ1bmN0aW9uIChlbGVtLCBhdHRyKSB7XG4gICAgICAgICAgICAgICAgLy9pZiAoIWF0dHIudGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyAgICB0aHJvdyBFcnJvcignVGVtcGxhdGUgbWlzc2luZyBmb3IgYWR2YW5jZWQgY2Fyb3VzZWwgaXRlbScpO1xuICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgIC8vcmV0dXJuIGN1cnJlbnRTY3JpcHRQYXRoLnJlcGxhY2UoJ2Nhcm91c2VsLWdlbmVyaWMtaXRlbS5qcycsICdjYXJvdXNlbC1nZW5lcmljLScgKyBhdHRyLnRlbXBsYXRlICsgJy5odG1sJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHIudGVtcGxhdGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NvcGUgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICBjb250cm9sbGVyICAgICAgOiBDb250cm9sbGVyLFxuICAgICAgICAgICAgY29udHJvbGxlckFzICAgIDogJ3ZtJyxcbiAgICAgICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcbiAgICAgICAgICAgICAgICBuZ01vZGVsICAgICAgICA6ICc9JyxcbiAgICAgICAgICAgICAgICBvblNlbGVjdCAgICAgICA6ICcmJyxcbiAgICAgICAgICAgICAgICBjYXJvdXNlbE9wdGlvbnM6ICc9J1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIENvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJ107XG4gICAgZnVuY3Rpb24gQ29udHJvbGxlcigkc2NvcGUpIHtcbiAgICAgICAgdmFyIHZtICAgICAgPSB0aGlzO1xuICAgICAgICB2bS5zZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIGFjdGl2YXRlKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gYWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAkc2NvcGUuJG9uKCdhLWNhcm91c2VsLml0ZW1zZWxlY3RlZCcsIGZ1bmN0aW9uIChldmVudCwgaXRlbSkge1xuICAgICAgICAgICAgICAgIHZtLnNlbGVjdGVkID0gaXRlbSA9PT0gdm0ubmdNb2RlbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufSkoKTtcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
